# NIO

1.4 도입됨

기존의 자바IO 에서는 문제가 있었는데, 블록킹(blocking) IO 이므로, 느림. 또 필수적인 파일 락킹(File Locking) 같은 기능도 지원되지 못해서 어쩔 수 없이 편법을 사용해서 개발.



## 자바의 IO는 왜 느릴까??

### 블록킹 Java IO

![image-20231203121731253](https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203121731253.png)

 

비효율적인 부분 2가지

1. 커널 영역 버퍼에서 프로세스 영역 안의 버퍼로 데이터를 복사한다는 점. 물리적 디스크에서 커널 영역의 버퍼로 데이터를 저장하는 것은 디스크 컨트롤러가 DMA라는 기술을 사용해서 CPU의 도움 없이도 처리할 수 있다. 하지만 커널 영역에서 프로세스 영역 버퍼로의 데이터 전달은 CPU가 관여해야만 한다. 만약, 커널 영역의 버퍼에 저장된 데이터를 직접 사용한다면 복사하는 시간을 단축할 수 있고, 복사 대상인 데이터의 가비지 컬렉션도 필요 없을 것.
2.  디스크 컨트롤러에서 커널 영역의 버퍼로 데이터를 복사하는 동안 프로세스 영역은 **블록킹**된다는 점.  많은 양의 데이터를 전달할 경우 효율이 떨어진다.

### IO 향상을 위한 운영체제 수준의 기술

#### 1. 버퍼

유저 영역과 커널 영역에서 버퍼를 사용한다.

**버퍼 사용의 성능 차이**

엄청남... ㄷㄷ

#### 2. Scatter/Gather

 동시에 각각의 버퍼를 쓰거나 읽는다고 가정하면? 시스템콜을 세번 호출해서 굉장히 비효율적일 것. 이런 단점을 보완하기 위해 Scatter/Gather 기술을 사용

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203125924198.png" alt="image-20231203125924198" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203130121648.png" alt="image-20231203130121648" style="zoom:50%;" />

이 기능을 사용하면, 시스템 콜을 한 번만 호출해도 된다. 다만, 시스템 콜을 한 번 호출할 때마다 사용할 버퍼의 주소 목록을 넘겨줌으로서, 운영체제에서는 최적화된 로직을 사용해서 주어진 버퍼들로부터 순차적으로 데이터를 읽거나 쓴다.

#### 3. 가상 메모리

 프로그램이 사용할 수 있는 주소 공간(Address Space)을 늘리기 위해 운영체제에서 지원하는 기술. **가상 메모리를 페이지(page)라는 고정된 크기로 나누고 각 페이지는 메모리가 아닌 디스크에 먼저 저장된다.** 그리고 실제 프로그램이 실행되는 데 필요한 페이지의 가상 주소만을 물리적 메모리(하드웨어의 램)주소로 바꾸어, 실제 메인 메모리에 올려놓는 것

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203130533887.png" alt="image-20231203130533887" style="zoom:50%;" />

 가상 메모리를 사용함으로써 생기는 장점은 두 가지 있는데, 이 중 하나가 실제 물리적 메모리크기보다 큰 가상 메모리 공간을 사용할 수 있다는 점. 다른 하나는 여러 개의 가상 주소가 하나의 물리적 메모리 주소를 참조함으로써 메모리를 효율적으로 사용할 수 있게 해준다는 점

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203130848853.png" alt="image-20231203130848853" style="zoom:50%;" />

 가상 메모리는 "실제 물리적 메모리 크기보다 큰 가상 메모리 공간을 사용할 수 있다"는 것 이는 **메모리페이징** 이라 하고, 1024,2048 사이즈로서, 운영체제에서 사용하는 페이징 크기로 물리적 디스크에 저장

#### 4. 메모리 맵 파일

 반복된 파일 입출력은 많은 가비지를 만들게 되고, 이것은 가비지콜렉터를 빈번하게 호출한다.  이런 이유들로 인해 파일의 크기가 커지면, 저장하거나 읽을 데이터의 크기가 클수록 성능은 더욱 나빠진다.

 이런 문제점을 해결하려고 운영체제에서 지원하는 것이 **Memory-mapper IO**

파일시스템의 페이지들과 유저 영역의 버퍼를 가상 메모리로 매핑시킨다.

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203131611821.png" alt="image-20231203131611821" style="zoom:50%;" />

Memory-mapper IO 은 파일시스템의 페이지들과 유저 영역의 버퍼를 가상 메모리로 매핑

장점

1. 프로세스가 파일 데이터를 메모리로서 바라보기 때문에 read(), write() 시스템 콜을 할 필요가 없다는 점. 따라서 프로세스가 파일 데이터를 변경하면 별도의 입출력 과정을 거치지 않고 변경된 부분을 물리적 디스크에 자동으로 반영하게 되고 커널 영역에서 유저 영역으로 버퍼를 복사할 필요도 없다. 프로세스가 파일 데이터를 변경하면 별도의 입출력 과정을 거치지 않고 변경된 부분을 물리적 디스크에 자동으로 반영하게 되고 커널 영역에서 유저 영역으로 버퍼를 복사할 필요도 없다.
2. 매우 큰 파일을 복사하기 위해 많은 양의 메모리를 소비하지 않아도 된다는 것. 파일 시스템의 페이지들을 메모리로서 바라보기 때문에 그때그때 필요한 부분만을 실제 메모리에 올려놓고 사용하면 되므로 효율적으로 메모리 사용

 NIO 에서는 ByteBuffer 를 상속하는 MappedByteBuffer 라는 클래스가 있는데, 이것이 메모리 맵 파일과 관련한 버퍼

#### 5. 파일 락

 프로세스가 어떤 파일에 락(lock)을 획득했을 때, 다른 프로세스가 그 파일로 동시에 접근하는 것을 막거나 또는 접근하는 방식에 제한을 두는 것

파일 락은 크게 공유(shared)락과 배타(exclusive)락. 두 가지로 나눌 수 있는데, 공유락은 읽기 작업할 때, 배타락은 쓰기 작업에 사용



**파일 락을 사용하는 가장 대표적인 프로그램은 DB 시스템**

<img src="https://raw.githubusercontent.com/LenKIM/images/master/2023-12-03/image-20231203132638359.png" alt="image-20231203132638359" style="zoom:50%;" />

//TODO 읽기 좀더 이해하기





### 자바의 새로운 변화

#### 1. 자바의 포인터 버퍼(Pointer buffer) 도입

 Buffer 클래스 도입. 

여기서 Buffer 는 프로세스 영역의 Buffer 가 아니라, 커널 영역에서의 Buffer 이다. 즉, 커널에 의해 관리되는 시스템 메모리를 직접 사용할 수 있는 Buffer 클래스가 도입. 이 클래스의 하부 구현은 C로 만들어져 있고, 우리는 추상화된 Buffer 사용.

#### 2. Native IO서비스를 제공해주는 Channel 도입

 채널은 Buffer 클래스와 함께 작업하도록 만들어져, 시스템 메모리인 버퍼에 직접적으로 데이터를 읽거나 쓸 수 있게 되었다는 것. 또한 채널을 앞서 알아봤던 Scatter/Gather 를 구현해 처리.



#### 3. Selector 도입

 Selector 도입. 셀럭터는 네트워크 프로그래밍의 효율을 높이기 위한 것으로 POSA2 에서 소개된 Reactor 패턴의 구현체.

 기존의 자바 네트워크 프로그래밍에서는 한계가 있고, 클라이언트 하나당 스레드 하나를 생성해서 처리해야 했는데, 사용자가 늘어나면 스레드가 많이 생성됨으로 인해 급격한 성능 저하를 가져왔으며 또한 구조적으로 많은 스레드를 생성해야 했기 때문에 메모리 또한 비효율적으로 사용. NIO 에서는 버퍼, 채널과 함께 사용되는 셀력터를 이용함으로써 단 한 개의 스레드만으로 수천에서, 수만 명의 동시 사용자를 처리할 수 있는 서버를 만들 수 있게 되었다.